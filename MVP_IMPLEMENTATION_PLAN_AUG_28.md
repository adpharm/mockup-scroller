# MVP Implementation Plan — “mockup-scroller” (Bun + TypeScript)

This plan specifies **exact behavior, files, dimensions, commands, and acceptance criteria** for a junior developer to implement a **local CLI** that:

1. **Takes PNGs exported from Figma**,
2. **Frames them in an iPhone SE bezel**,
3. **Animates a vertical scroll (if the image is taller than the screen)**,
4. **Exports a loopable GIF**.

No other features are included in the MVP.

---

## 1) Behavior (non-negotiable spec)

- **Input:** One or more **PNG** files (RGB, 8-bit, with or without alpha) from a local directory or glob.
- **Device:** **iPhone SE (portrait)**, **single variant** only.
- **Bezel/Screen:**

  - **Canvas (bezel) size:** **1000 × 2000 px**.
  - **Screen (viewport) size:** **750 × 1334 px** (matches classic iPhone SE logical aspect).
  - **Viewport top-left origin on the bezel canvas:** **(left: 125 px, top: 333 px)**.
  - **Screen corner radius:** **40 px** (applied as a mask to the content).
  - **Bezel look:** Simple rounded rectangle illustration; color **#0D0F12**; **no Apple logos**, **no trademarks**.
  - **Important:** The **bezel SVG must be transparent** except for the device vectors (no full-canvas background rect). Background is provided by code.

- **Background:** Solid **#0B0F13** (canvas color behind the device) — drawn by code, **not** inside the SVG.
- **Scroll animation:**

  - **FPS:** **30**.
  - **Duration:** **6.0 s** total.
  - **Easing:** **linear**.
  - **Path:** From y=0 (top) to y=`max(0, contentHeight − viewportHeight)`.

    - If `contentHeight ≤ viewportHeight`, **no scrolling** (top-aligned crop; animation still encodes 6s of identical frames).

- **Loop:** **Yes** (GIF repeats infinitely).
- **Output:** For each input PNG, produce:

  - **GIF** at **1000 × 2000 px** (full bezel canvas), filename pattern:
    `out/{basename}.framed.scroll.gif`
  - **Static PNG** preview (first frame), same size, filename pattern:
    `out/{basename}.framed.static.png`

- **Resizing of content:**

  - Input PNG is **resized to exactly fit viewport width = 750 px**, preserving aspect ratio.
  - Scrolling uses the resulting resized height vs. viewport height (1334 px).

- **Limits / guards:**

  - Reject input images with **width < 300 px** or **height < 500 px** (to avoid extreme upscaling).
  - Reject input images with **height > 20000 px** (to cap memory/compute).
  - Reject non-PNG formats.

---

## 2) Tooling & Versions

- **Runtime:** Bun **1.1.x** (tested with 1.1.19 or newer).
- **Language:** TypeScript **5.5.x**.
- **Libraries:**

  - `sharp@0.33.x` (image ops)
  - `commander@12.x` (CLI)
  - `globby@14.x` (file discovery)
  - `execa@9.x` (spawn ffmpeg)
  - `zod@3.x` (argument & config validation)

- **External dependency:** **ffmpeg** (installed on the system and resolvable on PATH).

  - macOS (Homebrew): `brew install ffmpeg`
  - Ubuntu/Debian: `sudo apt-get update && sudo apt-get install -y ffmpeg`
  - Windows (winget): `winget install Gyan.FFmpeg`

---

## 3) Project Structure

```
mockup-scroller/
  package.json
  bunfig.toml
  tsconfig.json
  src/
    cli.ts
    main.ts
    fileio.ts
    image.ts
    animate.ts
    encode.ts
    bezel/
      device-meta.ts
      svg/
        bezel.svg           # exact SVG below (Section 6)
        mask.svg            # exact SVG below (Section 6)
  assets/
    README.md               # explains the single supported device
  out/                      # generated by tool (gitignored)
  test-input/               # sample PNGs (gitignored)
```

- **No other devices** in MVP. Only the SE bezel/mask are allowed.

---

## 4) CLI & Commands

### 4.1 Installation (local dev)

```bash
bun install
```

### 4.2 Build

```bash
bun run build
```

### 4.3 Run (dev)

```bash
bun run dev --input "./test-input/*.png" --out "./out"
```

### 4.4 CLI Signature (MVP)

```
mockup-scroller --input <glob-or-dir> --out <directory>
```

- `--input` (required): glob pattern (quoted) or a directory path. Accepts only `.png` files.
- `--out` (required): output directory (created if missing).

**Exit codes:**

- `0` = success, at least one file processed.
- `2` = validation error (bad args, no matching PNGs).
- `3` = environment error (ffmpeg missing).
- `4` = processing error (per-file; continue others but return 4 if any failed).

---

## 5) Implementation Details

### 5.1 Type Definitions

```ts
// src/bezel/device-meta.ts
export interface DeviceMeta {
  canvas: { width: number; height: number }; // 1000 x 2000
  viewport: { x: number; y: number; width: number; height: number }; // 125,333,750,1334
  screenCornerRadius: number; // 40
  backgroundColor: string; // "#0B0F13"
}

export const IPHONE_SE_PORTRAIT: DeviceMeta = {
  canvas: { width: 1000, height: 2000 },
  viewport: { x: 125, y: 333, width: 750, height: 1334 },
  screenCornerRadius: 40,
  backgroundColor: "#0B0F13",
};
```

```ts
// src/image.ts
export interface LoadedImageMeta {
  width: number;
  height: number;
}

export interface FrameRenderSpec {
  inputPath: string;
  baseName: string; // file name without extension
  outDir: string; // output directory
}
```

### 5.2 Flow (strict sequence)

1. **Arg parsing & validation (cli.ts)**

   - Parse `--input`, `--out` (both required).
   - Resolve globs → file list (PNG only). If empty → exit code 2.
   - Check `ffmpeg` availability by running `ffmpeg -version`. If not found → exit code 3.

2. **Per-file processing (main.ts)**

   - For each PNG:

     - Validate image dimensions with `sharp.metadata()`.
     - Enforce limits:

       - width ≥ 300; height in \[500, 20000]

     - Call `renderAnimation(...)`.

3. **Rendering (animate.ts + image.ts)**

   - **Constants:** `FPS = 30`, `DURATION_SEC = 6`, `FRAMES = 180`.
   - **Resize strategy:**

     - Load input, **resize width to 750 px** with `sharp.resize({ width: 750, withoutEnlargement: false })`.
     - Let resized height be `Hc`.

   - **Scrollable calculation:**

     - `scrollable = Math.max(0, Hc - 1334)`.

   - **Per-frame vertical offset `y`:**

     - If `scrollable === 0`: `y = 0` for all frames.
     - Else linear: for frame `i in [0..179]`, `t = i / 179`, `y = Math.round(t * scrollable)`.

   - **Crop window each frame:**

     - Extract `{ left: 0, top: y, width: 750, height: 1334 }` from the resized content.

   - **Rounded corner mask:**

     - Apply **mask.svg** with `blend: "dest-in"` to the cropped content.

   - **Bezel composition (per frame):**

     - Create base canvas (1000×2000) with background `#0B0F13`.
     - Composite **masked content** at `(x:125, y:333)`.
     - Composite **bezel.png** **on top** at `(0, 0)`.
     - **Note:** Pre-render `bezel.svg` → PNG **once** per run (exact 1000×2000) and reuse.

   - **Frame file naming:**

     - Emit 180 PNGs to a temp folder:
       `out/{basename}.frames/{basename}.{frame-index-000000}.png`
       e.g. `out/homepage.frames/homepage.000000.png` … `000179.png`.

4. **GIF Encoding (encode.ts)**

   - **Two-pass palette** and deterministic numeric sequence:

     ```bash
     # 1) palette
     ffmpeg -y -framerate 30 -i "out/{basename}.frames/{basename}.%06d.png" \
       -vf "palettegen=stats_mode=diff" "out/{basename}.palette.png"

     # 2) apply palette
     ffmpeg -y -framerate 30 -i "out/{basename}.frames/{basename}.%06d.png" \
       -i "out/{basename}.palette.png" \
       -lavfi "paletteuse=dither=sierra2_4a" \
       "out/{basename}.framed.scroll.gif"
     ```

   - **Static PNG preview:** copy `000000.png` to
     `out/{basename}.framed.static.png`.
   - **Cleanup:** delete `out/{basename}.palette.png` and `out/{basename}.frames/` after successful GIF creation.

5. **Concurrency**

   - Process files **sequentially** (no parallelism; avoids RAM spikes).

6. **Errors**

   - If a file fails mid-process, log `ERROR: <file> <reason>`; continue other files.
   - Track failures; if any failed, exit code **4**, otherwise **0**.

---

## 6) Assets (exact SVGs)

The MVP **must not rely on external image files** beyond these two inline SVGs, rendered to PNG buffers via `sharp`. Dimensions **must not be changed**.

> Implementation: Load the SVG strings into `Buffer.from(svgString)` and feed into `sharp` as image inputs. Pre-render `bezel.svg` to **1000×2000** PNG at startup.

### 6.1 `bezel.svg` (1000×2000, transparent background)

```svg
<?xml version="1.0" encoding="UTF-8"?>
<svg width="1000" height="2000" viewBox="0 0 1000 2000" xmlns="http://www.w3.org/2000/svg">
  <!-- Device body (opaque) -->
  <rect x="50" y="30" width="900" height="1940" rx="100" ry="100" fill="#0D0F12" />
  <!-- Outer glass border (subtle stroke) -->
  <rect x="70" y="50" width="860" height="1900" rx="90" ry="90" fill="none" stroke="#1A1E25" stroke-width="4"/>
</svg>
```

### 6.2 `mask.svg` (750×1334, radius 40)

```svg
<?xml version="1.0" encoding="UTF-8"?>
<svg width="750" height="1334" viewBox="0 0 750 1334" xmlns="http://www.w3.org/2000/svg">
  <rect x="0" y="0" width="750" height="1334" rx="40" ry="40" fill="#ffffff"/>
</svg>
```

---

## 7) File I/O Rules

- **Input discovery:**

  - If `--input` is a **directory**, read `*.png` inside it (non-recursive).
  - If `--input` is a **glob**, resolve with `globby`.
  - Ignore hidden files and files <1 KB.

- **Output directories:**

  - Create `--out` if it doesn’t exist.
  - Create per-file temp frame dirs under `--out`.

- **File name sanitation:**

  - Take basename (strip extension), keep ASCII letters, digits, `_`, `-`. Replace spaces with `_`. Drop other chars.

---

## 8) Code Responsibilities (per module)

- `src/cli.ts`

  - Parse args with `commander`.
  - Validate presence & types with `zod`.
  - Resolve to absolute paths.
  - Verify ffmpeg via `execa("ffmpeg", ["-version"])`.
  - Call `main(...)`.

- `src/main.ts`

  - Expand input files via `globby` or directory read.
  - For each file: `processOne(file, outDir)`.
  - Track failure count; set exit code accordingly.

- `src/fileio.ts`

  - Helpers for path sanitation, mkdirp, cleanup of temp frames.
  - Verify file is PNG (extension + quick magic-number sniff: first 8 bytes `89 50 4E 47 0D 0A 1A 0A`).

- `src/bezel/device-meta.ts`

  - Exports `IPHONE_SE_PORTRAIT`.
  - Functions to return the **SVG buffers** (`bezelSvgBuffer()`, `maskSvgBuffer()`).

- `src/image.ts`

  - `loadMeta(path): Promise<LoadedImageMeta>`
  - `resizeToViewportWidth(path, targetWidth=750): Promise<Buffer>` → PNG buffer
  - `cropFrame(contentBuf, topY, viewportW, viewportH, maskSvgBuf): Promise<Buffer>`
  - `compositeOnCanvas(frameContentBuf, bezelPngBuf, deviceMeta): Promise<Buffer>`

    - Create base canvas (1000×2000) filled with `deviceMeta.backgroundColor`.
    - Composite **content** at `(125, 333)`.
    - Composite **bezel** on top at `(0, 0)`.
    - Output PNG buffer.

- `src/animate.ts`

  - `framesFor(heightContent: number): number[]`
    Returns array of integer `topY` per frame (length 180), linear from 0 → `scrollable`, or all zeros.
  - `renderAllFrames(spec: FrameRenderSpec, deviceMeta: DeviceMeta): Promise<void>`

    - Pre-render `bezel.svg` → PNG once (via `sharp`) at exactly **1000×2000** and reuse.
    - For `i in 0..179`:

      - Compute `topY`.
      - Build frame PNG → `out/{base}.frames/{base}.%06d.png`.

- `src/encode.ts`

  - `encodeGif(framesDir, baseName, outDir): Promise<void>` (two-pass ffmpeg with `%06d`).
  - `writeStaticPreview(framesDir, baseName, outDir): Promise<void>`
  - `cleanupTemp(framesDir, palettePath): Promise<void>`

---

## 9) Performance & Memory

- Process **one input at a time** (sequential).
- Do **not** hold all 180 frames in memory simultaneously:

  - For each frame, write PNG to disk immediately.

- Use PNG compression level 6 (sharp default); no tweaks in MVP.

---

## 10) Testing Instructions (manual)

1. Prepare **3 PNGs** in `test-input/`:

   - `short.png` (e.g., 750×1000) → should produce **no scroll** (repeated frames).
   - `tall.png` (e.g., 750×3000) → should **scroll** from top to bottom across 6s.
   - `wide.png` (e.g., 1600×6000) → should be **resized** to 750 width; scroll computed from resized height.

2. Run:
   `bun run dev --input "./test-input/*.png" --out "./out"`
3. Verify outputs:

   - `out/<name>.framed.scroll.gif` exists and loops.
   - `out/<name>.framed.static.png` exists.
   - Canvas is **1000×2000**; screen crop aligns at **(125, 333)**.
   - Corner radius clearly visible (no square corners).

---

## 11) Logging (required)

- On start: log Bun/Node versions, ffmpeg version, number of files matched.
- Per file: `PROCESSING: <abs path>`
- If rejected: `REJECTED: <path> <reason>`
- On success: `DONE: <basename> (gif, png)`.
- On failure: `ERROR: <basename> <message>`.
- Final summary: `Processed: X | Succeeded: Y | Failed: Z`.

---

## 12) Packaging (npm-ready)

- `package.json` fields:

  - `"name": "mockup-scroller"`
  - `"type": "module"`
  - `"bin": { "mockup-scroller": "./dist/cli.js" }`
  - `"exports": { ".": "./dist/main.js" }`
  - `"engines": { "bun": ">=1.1.19" }`

- Build script emits ESM JS to `dist/`.
- CLI must be runnable as:

  - local dev: `bun run dev ...`
  - installed: `npx mockup-scroller --input "./images/*.png" --out "./out"` (post-publish)

### package.json (exact)

```json
{
  "name": "mockup-scroller",
  "version": "0.1.0",
  "private": true,
  "type": "module",
  "bin": {
    "mockup-scroller": "./dist/cli.js"
  },
  "exports": {
    ".": "./dist/main.js"
  },
  "scripts": {
    "build": "tsc -p tsconfig.json",
    "dev": "bun run src/cli.ts"
  },
  "engines": {
    "bun": ">=1.1.19"
  },
  "dependencies": {
    "commander": "^12.1.0",
    "execa": "^9.3.0",
    "globby": "^14.0.2",
    "sharp": "^0.33.4",
    "zod": "^3.23.8"
  },
  "devDependencies": {
    "typescript": "^5.5.4"
  }
}
```

### bunfig.toml

```toml
[package]
  name = "mockup-scroller"

[define]
  __DEV__ = "true"
```

### tsconfig.json

```json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ES2022",
    "moduleResolution": "Bundler",
    "strict": true,
    "outDir": "dist",
    "rootDir": ".",
    "esModuleInterop": true,
    "skipLibCheck": true,
    "resolveJsonModule": true
  },
  "include": ["src/**/*.ts"]
}
```

---

## 13) Acceptance Criteria (must all pass)

- ✅ Running the CLI exactly as:

  ```bash
  bun run dev --input "./test-input/*.png" --out "./out"
  ```

  produces **one GIF** and **one static PNG** per valid input PNG.

- ✅ The GIFs are **1000×2000**, loop infinitely, and display the content within the screen mask at **(125, 333)** with a **40 px corner radius**.
- ✅ Scroll animation is linear over **6.0 seconds** at **30 FPS**, **top to bottom**, or static if no scrollable height.
- ✅ Invalid inputs (too small, too tall, not PNG) are rejected with explicit reasons, and do not stop other files.
- ✅ `ffmpeg` absence is detected and the tool exits with code 3.
- ✅ Output filenames match the pattern in Section 1.
- ✅ No additional flags, devices, or formats are present.

---

## 14) Tasks Checklist (execution order)

1. Initialize repo with Bun + TS + config files.
2. Implement `cli.ts` with `commander` + `zod` validation.
3. Implement `device-meta.ts` and embed **transparent** `bezel.svg` + `mask.svg` buffers.
4. Implement `fileio.ts` (glob/dir resolution, mkdirp, cleanup).
5. Implement `image.ts` (load, resize, crop+mask, composite).
6. Implement `animate.ts` (frame offsets, full frame rendering).
7. Implement `encode.ts` (two-pass ffmpeg with `%06d`, static preview, cleanup).
8. Implement logging and error codes as specified.
9. Manual tests (Section 10).
10. Prepare `package.json` bin and exports; confirm local `bun run dev` and `bun run build`.

---

## 15) Out of Scope (explicitly not in MVP)

- No MP4/WebM export.
- No configurable device, color, backgrounds, timing, easing, or sizes.
- No status bar overlays, scrollbars, shadows, or multiple orientations.
- No parallel processing.
- No Figma API integration (inputs are local PNGs only).
- No GUI.
